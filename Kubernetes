                                                                        Core Concepts

1) Архитектура kubernetes

Node
1. Master
Service:
ETCD - Высокодоступное хранилище типа ключ-значение, представляет собой NoSQL базу данных
Scheduler - Планировщик определяющий правильную Node для развертывания приложения, для определения рабочего узла Scheduler берет во внимание требования приложения ресурсам узла, емкость рабочих Node и т.д.
Controller Manager - Node-Controller, replication-controller (Более новый вариант Replica set) и т.д.
API Server - набор публичных свойств и методов для взаимодействия с другими приложениями.
Container runtime - Среда исполнения контейнеров (Docker. Conteinerd. CRI-O)
Kublet - Агент kubernetes
Kube Proxy - Обеспечивает связь между всеми узлами кластера
CNI - Сетевой плагин (Flunnel, Calico и т.д.)

2. Worker
Kublet - Агент kubernetes
Container runtime - Среда исполнения контейнеров (Docker. Conteinerd. CRI-O)
Kube Proxy - Обеспечивает связь между всеми узлами кластера
CNI - Сетевой плагин (Flunnel, Calico и т.д.)

2) Конфигурирование ETCD

3) Устройство взаимодействия компонентов кластера через API Server

4) Controller Manager 
Namespace Controller
ServiceAccount Controller
PV-Binder Controller
Replication Controller
PV-Protection Controller
Endpoint Controller
Deployment Controller
Node Controller
Statefulset Controller
Job Controller
CronJob Controller
Replicaset Controller

5) Scheduler

6) Агент kubernetes Kubelet

7) Kube Proxy

8) Namespaces in Kubernetes
Default - это пространство имен которое создается автоматически когда кластер впервые настраивается, это нужно для того чтобы kubernetes при создании собственных механизмов мог разделить нагрузки, это разделение предотвращает случайное удаление или модификацию системных компонентов, перенося их в специальное пространство имен kube-system
kube-public - пространство имен которое создается автоматически, здесь находятся ресурсы необходимые всем пользоваателям кластера,  
Обязательное разделение кластера на Dev и Prod namespaces, также обязательно настроить для них отдельные политики, к примеру использование ресурсов.
Для того чтобы один Pod мог подключится к другому Pod в другом пространстве имен, необходимо в конфиге прописать даные для подключения по шаблону nameservice.namespace.typeservice.domainnamecluster
пример: db-service.dev.svc.cluster.local <----- FQDN service

9) Imperative и Declarative подход
Imperative - это когда приходится систему шаг за шагом инструктировать для выполнения действий
Пример: последовательное выполнение комманд в CMD или Terminal Linux
Declarative - это когда система сама определяет что нужно сделать для решения той или иной задачи. Мы используем одну и туже команду создания, обновления или изменения объекта.
Пример: kubectl apply -f app.yaml или команда запуска playbook Ansible.

10) О том как работает команда kubectl apply
Допустим, что мы уже ранее сделали deploy нашего приложения, и у нас теперь есть три файла конфигурации:
Локальный файл конфигурации который храниться локально на сервере или в репозитории (GitHub, GitLab, Nexus), файл конфигурации который храниться в памяти кубернетеса как последняя примененная конфигурация и сконвертированный yaml файл в json конфигурацию развернутого приложения.
При использовании команды kubectl apply происходит изменение состояния объекта с изменением трех файлом конфигурации.
Локальный мы изменили и применили, изменилась конфигурация в памяти kubernetes и изменилась конфигурация json объекта.


                                                                          Scheduling
1) Manual Scheduling
Как работает Scheduling, принцип работы состоит в том чтобы планировать нагрузку, определять какой Node подходит под данное приложение

                                                                     Logging и Monitoring
1) Monitor cluster components
Узнать об устройстве мониторинга кластера kubernetes

                                                                      Cluster Maintenance
1) Operating system upgrades
Предположим что нам необходимо на Node выполнить техническое обслуживание.
Пример: Обновить ядро OS или установить какой-нибудь программный комплекс.
Нам необходимо вывести Node из кластера, для этотго выполняем команду: kubectl drain node01, вовремя выполнения команды Pods аккуратно завершат свою работу и будут перенесены на другой Node.
Чтобы вернуть Node в кластер kubernetes нам необходимо выполнить команду: kubectl uncordon node1
После выполнения команды, нагрузка снова будет назначаться на этот Node, но Pods которые были перенесены на другой Node продолжат выполнятся на Node в которую они были выселены и вернутся обратно только при удалении на новом Node, и если Scheduling назначит Pods обратно на старый Node
Чтобы просто запретить планирование Pods на Node необходимо выполнить команду: kubectl cordon node01






                                                                         Общая информация

1. Правило масштабирования в кластере kubernetes:
Один Pod - один контейнер 
Для создания еще одного или нескольких контейнеров в Pod, необходимо убедиться что контейнеры не одного типа
Вертикальное масштабирование - создание нового Pod
Горизонтальное масштабирование - создание нового Node

2. Для чего нужен Replica set (Replication controller устаревшая технология)
Контролирует доступность приложения при выходе из строя одного из Pod
Поддержиает необходимое колличество экземпляров Pod для обеспечения доступности приложения
Может охватывать несколько Node
Может отслеживать ранее созданные приложения

3. Для чего нужен Deployment set (в иерархии стоит выше Replicaset)
Позволяет обновить все приложения последовательно, а не все сразу, так как обновление всех контейнеров одновременно может привести к простою приложения (rolling updates или плавающее обновление)
Позволяет отменять именение
Позволяет останавливать именения
Позволяет возобновлять изменения 
rolling updates - стратегия обносления по умолчанию
Deployment set автоматически создает Replica set
При обновлении создается новый Replica set который создает новые экземпляры приложения, при этом последовательно удаляя старые

4. Сетевое взаимодействие
Сетевой адрес Node для подключения по ssh
Приватная сеть kubernetes
Сетевой адрес Pod
Все Pod должны уметь связываться между собой без использования NAT
Все Node должны уметь связываться c любыми контейнерами без использования NAT

При выборе плагина стоит обратить на следующие особенности плагина:
Конфигурирование (простота установки)
Безопасность (Шифрование и NetworkPolices)
Производительность (Скорость обработки данных)
Потребления ресурсов (Сколько требуется выделить RAM, CPU и т.д.)


